(function () {
	var obj =  function (env, pkg, _pool, server, isSSL) {
		let me = this;
		me.mapping = {};

		me.getSN = function() {
			this._SN = (!this._SN || this._SN > 999999) ? 1 : (this._SN + 1);
			return '' + this._SN;
		}
		me.hubLink = function(link_url, host, callback, err_callback) {
			let me = this;
			var ioClient = require(env.root_path + '/package/socket.io-client/node_modules/socket.io-client');

			//if (!me.ioPool[link_url] || !me.ioPool[link_url].connected) {
			if (!_pool.sockets[link_url]) {
				var link = ioClient.connect(link_url, {reconnection: false, timeout:3000, 'connect_timeout': 3000});

				link.on('connect', function() {
					_pool.sockets[link_url] = {
						link : link, 
						created : new Date().getTime(),
						actived : new Date().getTime(),
						socket_from : host
					};
					console.log('--connect_ed-->' + link_url);
					callback(link, false);
				});
				link.on('disconnect', function() {
					delete _pool.sockets[link_url];
				});
				link.on('connect_error', function(error){
					console.log('--connect_error--->');
					link.disconnect();
					delete _pool.sockets[link_url];
					err_callback();
				});

				link.on('connect_timeout', (timeout) => {
					
					console.log('--connect_timeout--->');
					
					link.disconnect();
					delete _pool.sockets[link_url];
					err_callback();
				});
			} else {
				if (_pool.sockets[link_url].link.connected) {
					_pool.sockets[link_url].actived = new Date().getTime(),
					callback(_pool.sockets[link_url].link,  true);
				}
			}
		}
		me.commLink = function(link_url, host, callback, err_callback) {
			let me = this;
			var ioClient = require(env.root_path + '/package/socket.io-client/node_modules/socket.io-client');

			//if (!me.ioPool[link_url] || !me.ioPool[link_url].connected) {
			if (!_pool.sockets[link_url]) {
				var link = ioClient.connect(link_url, {reconnection: false, timeout:3000, 'connect_timeout': 3000});

				link.on('connect', function() {
					_pool.sockets[link_url] = {
						link : link, 
						created : new Date().getTime(),
						actived : new Date().getTime(),
						socket_from : host
					};
					callback(link, false);
				});
				link.on('disconnect', function() {
					delete _pool.sockets[link_url];
				});
				link.on('connect_error', function(error){
					link.disconnect();
					delete _pool.sockets[link_url];
					err_callback();
				});

				link.on('connect_timeout', (timeout) => {
					link.disconnect();
					delete _pool.sockets[link_url];
					err_callback();
				});
			} else {
				if (_pool.sockets[link_url].link.connected) {
					callback(_pool.sockets[link_url].link,  true);
				} else {
					err_callback();
				}
			}
		}
		me.domainList =  function() {
			let me = this, DS_m = {}, DS_d = {}, DS = {};	
			delete require.cache[env.config_path + '/main_dns.json'];
			delete require.cache[env.config_path + '/dynamic_dns.json'];
			try { 
				DS_m = require(env.config_path + '/main_dns.json'); 
			    	DS_d = require(env.config_path + '/dynamic_dns.json');
			} catch(e) {}
			Object.assign(DS, DS_m, DS_d);
			return DS;
		};
		
		me.serverRule = function(N) {
			var TP = ['comm', 'commion'], ENV = ['dev', 'prod', 'qa'];
			for (var i = 0; i < TP.length; i++) {
				for (var j = 0; j < ENV.length; j++) {
					var patt = new RegExp('^'+ TP[i] +'([0-9]+)\_' + ENV[j] + '\.([a-z0-9]+)\.([a-z]+)$', 'ig');
					if (patt.test(N)) return true;
				}
			}
			return false;
		}

		me.isPipeServer = function(host) {
			var TP = ['pipe'], ENV = ['dev', 'prod', 'qa'];
			for (var i = 0; i < TP.length; i++) {
				for (var j = 0; j < ENV.length; j++) {
					var patt = new RegExp('^'+ TP[i] +'([0-9]+)\_' + ENV[j] + '\.([a-z0-9]+)\.([a-z]+)$', 'ig');
					if (patt.test(host)) return true;
				}
			}
			return false;
		}

		me.isIOSType = function(host, type) {
			var ENV = ['dev', 'prod', 'qa'];

			for (var i = 0; i < ENV.length; i++) {
				var patt = new RegExp('^'+ type +'([0-9]+)\_' + ENV[i] + '\.([a-z0-9]+)\.([a-z]+)$', 'ig');
				if (patt.test(host)) return true;
			}
	
			return false;
		}
		
		me.getCluster = function (host) {
			let me = this, DS = me.domainList();
			if (!DS[host]) return [];
			let list = {}, ip_list = [];
			for(o in DS) {
				if (me.serverRule(host) && me.serverRule(o))  { 
					 if (DS[o] !== DS[host]) {
						 if (ip_list.indexOf(DS[o]) === -1) {
							list[o] = DS[o];
							ip_list.push(list[o])
						 }
					}
				}
			}
			return list;
		};
		me.getTypeCluster = function (type) {
			let me = this, DS = me.domainList();
			let list = {}, ip_list = [];
			for(o in DS) {
				if (me.isIOSType(o, type) && ip_list.indexOf(DS[o]) === -1) {
					list[o] = DS[o];
					ip_list.push(list[o]);
				}
			}
			return list;
		};
		
		
		me.host2ip = function (host) {
			let me = this, DS = me.domainList();
			return DS[host];
		};
		me.ip2host = function (ip) {
			let me = this, DS = me.domainList();
			for (var o in DS) { if (DS[o] === ip) return o; }
			return false;
		};
		
		me.io = require( env.root_path + '/package/socket_io/node_modules/socket.io').listen(server);
		me.io.on("connection", (socket) => {
			let me = this;
			var host = (!socket || !socket.handshake || !socket.handshake.headers) ? '' : socket.handshake.headers.host;
			if (pkg.comm.isIp(host)) {
				return true;
			}
			
			if (me.isIOSType(host, 'commion')) {
				delete require.cache[env.root_path + '/modules/io/node_modules/ionApp.js'];
				let ionAPP =  require(env.root_path + '/modules/io/node_modules/ionApp.js');
				try {
					new ionAPP(me, env, pkg, _pool, server, host, isSSL).onConnection(socket);
				} catch (err) {
					console.log(err);
					me.io.to(socket.id).emit('ionAppError', err.mrssage);
					socket.disconnect();
				}			
			
			} else if (me.isPipeServer(host)) {
				delete require.cache[env.root_path + '/modules/io/node_modules/ioPipe.js'];
				let ioPipe =  require(env.root_path + '/modules/io/node_modules/ioPipe.js');
				try {
					new ioPipe(me, env, pkg, _pool, server, host, isSSL).onConnection(socket);
				} catch (err) {
					me.io.to(socket.id).emit('ioAppError', err.mrssage);
					socket.disconnect();
				}			
			} else {
				console.log('888>');
				delete require.cache[env.root_path + '/modules/io/node_modules/commApp.js'];
				let ioAPP =  require(env.root_path + '/modules/io/node_modules/commApp.js');
				try {
					new commAPP(me, env, pkg, _pool, server, host, isSSL).onConnection(socket);
				} catch (err) {
					me.io.to(socket.id).emit('ioAppError', err.mrssage);
					socket.disconnect();
				}			
			}

		});		
	};
	
	if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
		module.exports = obj;
	} 
	
})();
