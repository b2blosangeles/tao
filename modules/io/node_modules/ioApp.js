(function () {
	var obj =  function (env, pkg, server, isSSL) {
		let me = this;
		
		this.getCluster = function (host) {
			let me = this, DS_m = {}, DS_d = {}, DS = {};	
			delete require.cache[env.config_path + '/main_dns.json'];	
			try { DS_m = require(env.config_path + '/main_dns.json'); } catch(e) {}
			
			delete require.cache[env.config_path + '/dynamic_dns.json'];	
			try { DS_d = require(env.config_path + '/dynamic_dns.json'); } catch(e) {}
			
			Object.assign(DS, DS_m, DS_d);
			if (!DS[host]) return [];
			let list = {}, ip_list = [];
			for(o in DS) {
				if (
					(host.match(/^comm([0-9]+)\_dev\.([a-z0-9]+)\.([a-z0-9]+)$/ig) &&
						o.match(/^comm([0-9]+)\_dev\.([a-z0-9]+)\.([a-z0-9]+)$/ig)) 
					|| (host.match(/^comm([0-9]+)\_prod\.([a-z0-9]+)\.([a-z0-9]+)$/ig) &&
						o.match(/^comm([0-9]+)\_prod\.([a-z0-9]+)\.([a-z0-9]+)$/ig))
					|| (host.match(/^comm([0-9]+)\_qa\.([a-z0-9]+)\.([a-z0-9]+)$/ig) &&
						o.match(/^comm([0-9]+)\_qa\.([a-z0-9]+)\.([a-z0-9]+)$/ig))
				) { 
					 if (DS[o] !== DS[host]) {
						 if (ip_list.indexOf(DS[o]) === -1) {
							list[o] = DS[o];
							ip_list.push(list[o])
						 }
					 }
				}
				
			}
			return list;
		};
		
		me.hubService = function (cfg, incomeData) {
			let me = this, clusters =  me.ioApp(env, pkg, server, isSSL).getCluster(cfg.host);
			var ioClient = require(env.root_path + '/package/socket.io-client/node_modules/socket.io-client');
			
			var CP = new pkg.crowdProcess(), _f = {};
			for(o in clusters) {
				_f[o] = (function(o) { 
					return function(cbk) {
						var link_url = ((isSSL) ? 'https://' : 'http://') + o + '/';
						var ioCSocket = ioClient.connect(link_url, {reconnection: false, timeout:3000, 'connect_timeout': 3000});
						
						ioCSocket.on('connect', function() {
							if (incomeData.data) {
								ioCSocket.emit('hubProxy', {
								    from : incomeData.from,
								    proxy : ioCSocket.id,
								    to : incomeData.to,
								    data : incomeData.data
								  }, (data) => {});
							} 									
							ioCSocket.disconnect();
							cbk(true);
						});

						ioCSocket.on('connect_error', function(error){
						    cbk(false);
						});
						
						ioCSocket.on('connect_timeout', (timeout) => {
							 cbk(false);
						});
						
						ioCSocket.on('disconnected', function(){
						    cbk(true);
						});
						
					} 
				})(o)
			}
			CP.serial(_f, function(data) {
			}, 30000);
		};
	};
	
	if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
		module.exports = obj;
	} 
	
})();
