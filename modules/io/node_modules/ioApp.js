(function () {
	var obj =  function (IO, env, pkg, _pool, server, host, isSSL) {
		let me = this;
	
		this.clientToclient = function (incomeData) {
			let me = this;
			var CA = incomeData.toClient.split('->');
			if (CA.length === 2 && pkg.comm.isIp(CA[0])) {
				var link_url = ((isSSL) ? 'https://' : 'http://') + IO.ip2host(CA[0]) + '/';
				IO.hubLink(link_url, host,
					function(client_socket,  pool) {
						client_socket.emit('hubProxy', {
							session_id 	: incomeData.session_id,
							to : '/#' + CA[1],
							data 		: {
								fromClient : IO.mapping[incomeData.fromClient],
								toClient : IO.mapping[incomeData.toClient],
								body : incomeData.data.body,
								POOL : me._socket.id + '--9999--> -' +  host,
								getCluster : IO.getCluster(host),
								p : pool
							}
						});
					},
					function() {
					}
				);
			}
		}
		
		this.hubRoom = function (incomeData) {
			let me = this, clusters =  IO.getCluster(host);
			
			var CP = new pkg.crowdProcess(), _f = {};
			
			_f['self'] = function(cbk)  {
				var uniqueId = me.CommIP + '->'  + incomeData.from.replace(/\/\#/g, '');
				console.log('---incomeData.from--->');
				console.log(incomeData.from);
				me.deliveryMessage(incomeData.to, {
				    code : 'roomMessage',
				    from : incomeData.from,
				    to : incomeData.to,
				    data : {
						fromClient : IO.mapping[uniqueId],
					    	toClient : incomeData.to,
						body : incomeData.data.body
					}
				});
			};
			for(o in clusters) {
				_f[o] = (function(o) { 
					return function(cbk) {
						
					var link_url = ((isSSL) ? 'https://' : 'http://') + o + '/';
					IO.hubLink(link_url, host,
						function(client_socket, pool) {
							client_socket.emit('hubProxy', {
							    session_id : incomeData.session_id,
							    from : incomeData.from,
							    proxy : client_socket.id,
							    to : incomeData.to,
							    data : incomeData.data,
							    isRoom : true,
							    p : pool
							}); 
							cbk(true);
						},
						function() {
							cbk(false);
						});
					}	
					
				})(o)
			}
			CP.parallel(_f, function(data) {
			}, 60000);
		};

		this.hubRoomBroadcast = function (room, incomeData, localData) {
			let me = this, clusters =  IO.getCluster(host);
			
			var CP = new pkg.crowdProcess(), _f = {};
			
			_f['self'] = function(cbk)  {
				me.deliveryMessage(room, ((!localData) ? incomeData : localData));
				cbk(true);
			};
			for(o in clusters) {
				_f[o] = (function(o) { 
					return function(cbk) {
					var link_url = ((isSSL) ? 'https://' : 'http://') + o + '/';
					IO.hubLink(link_url, host,
						function(client_socket, pool) {
							client_socket.emit('hubProxyRoomBroadcast', {
								room : room,
								data : incomeData
							}); 
							cbk(true);
						},
						function() {
							cbk(false);
						});
					}	
					
				})(o)
			}
			CP.parallel(_f, function(data) {
			}, 60000);
		};
		
		
		this.hubQuery = function (room, session_id, IO, callback) {
			let me = this, clusters =  IO.getCluster(host);
			var CP = new pkg.crowdProcess(), _f = {};
			_f['self'] = function(cbk)  {
				IO.io.in(room).clients((err, clients) => {
					var obj_clients = {};
					for (var i = 0 ;  i < clients.length; i++) {
						//var uniqueId = pkg.comm.getSERVERID() + '_' + clients[i].replace(/\/\#/g, '');
						var uniqueId = me.CommIP  + '->' + clients[i].replace(/\/\#/g, '');
						obj_clients[uniqueId] =  (IO.mapping[uniqueId]) ? IO.mapping[uniqueId] : '';
					}
					cbk(obj_clients);
				});
			};
			for(o in clusters) {
				_f[o] = (function(o) { 
					return function(cbk) {
						var link_url = ((isSSL) ? 'https://' : 'http://') + o + '/';
						IO.hubLink(link_url, host,
						function(client_socket, pool) {
							client_socket.on('hubQueryClients_' + session_id, function(data){
								client_socket.off('hubQueryClients_' + session_id);
								// client_socket.disconnect();
								cbk(data);
							      });
							client_socket.emit('hubQueryClients', {room:  room, hub : o, session_id: session_id,  p : pool});
						},
						function() {
							
							cbk(false);
						});
					}
				})(o)
			}
			CP.parallel(_f, function(data) {
		//	CP.serial(_f, function(data) {
				var clients = {};
				for (o in data.results) {
					if (typeof data.results[o] === 'object') {
						for (p in data.results[o]) {
							clients[p] = data.results[o][p]
						}
					}
				}
				callback({room	: room, clients	: clients});
			}, 6000);
		};
		
		me.callbackMessage = function (data) {
			let me = this;
			data.socket = me._socket.id;
			IO.io.to(me._socket.id).emit('callbackMessage', data);	
		//	IO.io.to(me._socket.id).emit('callbackMessage_' + data.session_id, data);
		};
		me.deliveryMessage = function (toId, data) {
			let me = this;
			IO.io.to(toId).emit('_incomeMessage_', data);	
		};
	
		me.onConnection = function (socket) {

			me.CommIP = IO.host2ip(host);
			me._socket = socket;
			
			if (!me.CommIP) {
				return true;
			}
			var uniqueId = me.CommIP  + '->' + socket.id.replace(/\/\#/g, '');
			
			IO.io.to(socket.id).emit('uniqueId', uniqueId);
			IO.mapping[uniqueId] = '';
			
			var sequenceNumberByClient = new Map();	
			
			if(!host.match(/^comm([0-9]+)\_(qa|dev|prod)\.([a-z0-9]+)\.([a-z0-9]+)$/ig)) { 
				socket.disconnect();
				return true;
			} 

			socket.on('clientRequest', function(incomeData){ 
				incomeData.session_id = new Date().getTime() + '.' + ((!incomeData.session_id) ? '' : incomeData.session_id)  + '.' + IO.getSN();
				switch(incomeData.cmd) {
					case 'sendToRoom':
						if (!incomeData.room) {
							me.callbackMessage({
								session_id : incomeData.session_id,
								data: {success : false, data: 'Unsuccess'}
							});
						} else {
							var _f = function () {
								IO.io.in(incomeData.room).clients((err, clients) => {
									if (!err)  {
										me.hubRoom({
											session_id : incomeData.session_id,
											data : incomeData.data,
											from: socket.id,
											to : incomeData.room
										});
									}
								});
							};
						//	 socket.join(incomeData.room, function() {	
								 _f();
						//	});
						}
						break;

					
					case 'clientToclient':
						if (incomeData.toClient) {
							incomeData.fromClient =  uniqueId;
							if (!incomeData.toClient) {
								/*
								me.callbackMessage({
									session_id : incomeData.session_id,
									data: {success : false, data: 'Unsuccess'}
								});
								*/
							} else {
								me.clientToclient(incomeData);
								
							}	
						}
						break;
					case 'leaveRoom':
						socket.leave(incomeData.room,  function() {
							me.hubQuery(incomeData.room, incomeData.session_id, IO,
								function(data) {
								/*
									me.hubRoomBroadcast(incomeData.room, {
										code : 'roomClients', 
										clients : (!data || !data.clients) ? {} : data.clients
									}, {
										code : 'roomClients', 
										clients : {}
									 });
								*/	
								me.hubRoomBroadcast(incomeData.room,  {
										code : 'roomClients', 
										clients : {}
									 });
								});
						});
						break;
					case 'joinRoom':
						if (!incomeData.room) {
							me.callbackMessage({
								session_id : incomeData.session_id,
								data: {success : false, data: 'Miss room'}
							});
						} else {
							socket.join(incomeData.room, function() {
								me.hubQuery(incomeData.room, incomeData.session_id, IO,
									function(data) {
										me.hubRoomBroadcast(incomeData.room, {
										code : 'roomClients', 
										clients : (!data || !data.clients) ? {} : data.clients
										});
									});
							});
						}
						break;
						
					case 'roomClients':
						me.hubQuery(incomeData.room, incomeData.session_id, IO,
						    function(data) {
							me.callbackMessage({
								session_id : incomeData.session_id,
								data: {data:data, success : true}
							});
						});
						break;
					case 'adminSocketsPool':
						var DT =  [];
						for (var o in _pool.sockets) {
							var DTO = {};
							for (var p in _pool.sockets[o]) {
								DTO[p] = (p !== 'link') ? _pool.sockets[o][p] : _pool.sockets[o].link.id 		
							}
							DT.push(DTO);
						}
						me.callbackMessage({
							session_id : incomeData.session_id,
							data: {success : true, DT: DT}
						});
						break;
					default : 
						me.callbackMessage({
							session_id : incomeData.session_id,
							data: {success : false, data: 'miss cmd'}
						});
				}
			});
			
			socket.on('hubProxy', function(incomeData){
				incomeData.data.p = incomeData.p;
				console.log('---incomeData.isRoom--2->');
				console.log(incomeData.isRoom );
				IO.io.to(incomeData.to).emit('clientMessage', {
					session_id : incomeData.session_id,
					data: incomeData.data,
					proxy: socket.id,
					from: incomeData.from,
					to : incomeData.to
				});
				//=== To Do
				me.deliveryMessage(incomeData.to, {
					code : 'clientMessage',
					data: incomeData.data,
					proxy: socket.id,
					from: incomeData.from,
					to : incomeData.to
				});
			});

			socket.on('hubProxyRoomBroadcast', function(incomeData){
				me.deliveryMessage(incomeData.room, incomeData.data);
			});			
			
			socket.on('hubQueryClients', function(incomeData){
				IO.io.in(incomeData.room).clients((err, clients) => {
					var obj_clients = {};
					for (var i = 0 ;  i < clients.length; i++) {
						// var uniqueId = pkg.comm.getSERVERID() + '_' + clients[i].replace(/\/\#/g, '');
						var uniqueId = me.CommIP + '->'  + clients[i].replace(/\/\#/g, '');
						obj_clients[uniqueId] = (IO.mapping[uniqueId]) ? IO.mapping[uniqueId] : '';
					}
					IO.io.to(`${socket.id}`).emit('hubQueryClients_' + incomeData.session_id, obj_clients);
				});
			});
			socket.on('setClientInfo', function(clientInfo){
			    // var uniqueId = pkg.comm.getSERVERID() + '_' + socket.id.replace(/\/\#/g, '');
			     var uniqueId = me.CommIP + '->' + socket.id.replace(/\/\#/g, '');
			     IO.mapping[uniqueId] = clientInfo;
			});			

			sequenceNumberByClient.set(socket, 1);
			socket.on("disconnect", () => {
				delete IO.mapping[uniqueId];
				sequenceNumberByClient.delete(socket);
			});
		};
		
	};
	
	if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
		module.exports = obj;
	} 
})();
