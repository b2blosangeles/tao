(function () {
	var obj =  function (env, pkg, server, isSSL) {
		let me = this;
		var ioClient = require(env.root_path + '/package/socket.io-client/node_modules/socket.io-client');
		this.getSN = function() {
			this._SN = (!this._SN || this._SN > 999999) ? 1 : (this._SN + 1);
			return '' + this._SN;
		}
		this.getCluster = function (host) {
			let me = this, DS_m = {}, DS_d = {}, DS = {};	
			delete require.cache[env.config_path + '/main_dns.json'];	
			try { DS_m = require(env.config_path + '/main_dns.json'); } catch(e) {}
			
			delete require.cache[env.config_path + '/dynamic_dns.json'];	
			try { DS_d = require(env.config_path + '/dynamic_dns.json'); } catch(e) {}
			
			Object.assign(DS, DS_m, DS_d);
			if (!DS[host]) return [];
			let list = {}, ip_list = [];
			for(o in DS) {
				if ((host.match(/^comm([0-9]+)\_dev\.([a-z0-9]+)\.([a-z0-9]+)$/ig) &&
						o.match(/^comm([0-9]+)\_dev\.([a-z0-9]+)\.([a-z0-9]+)$/ig)) 
					|| (host.match(/^comm([0-9]+)\_prod\.([a-z0-9]+)\.([a-z0-9]+)$/ig) &&
						o.match(/^comm([0-9]+)\_prod\.([a-z0-9]+)\.([a-z0-9]+)$/ig))
					|| (host.match(/^comm([0-9]+)\_qa\.([a-z0-9]+)\.([a-z0-9]+)$/ig) &&
						o.match(/^comm([0-9]+)\_qa\.([a-z0-9]+)\.([a-z0-9]+)$/ig))
				) { 
					 if (DS[o] !== DS[host]) {
						 if (ip_list.indexOf(DS[o]) === -1) {
							list[o] = DS[o];
							ip_list.push(list[o])
						 }
					 }
				}
				
			}
			return list;
		};
		this.host2ip = function (host) {
			let me = this, DS_m = {}, DS_d = {}, DS = {};	
			delete require.cache[env.config_path + '/main_dns.json'];	
			try { DS_m = require(env.config_path + '/main_dns.json'); } catch(e) {}
			
			delete require.cache[env.config_path + '/dynamic_dns.json'];	
			try { DS_d = require(env.config_path + '/dynamic_dns.json'); } catch(e) {}
			
			Object.assign(DS, DS_m, DS_d);
			return DS[host];
		};
		this.ip2host = function (ip) {
			let me = this, DS_m = {}, DS_d = {}, DS = {};	
			delete require.cache[env.config_path + '/main_dns.json'];	
			try { DS_m = require(env.config_path + '/main_dns.json'); } catch(e) {}
			
			delete require.cache[env.config_path + '/dynamic_dns.json'];	
			try { DS_d = require(env.config_path + '/dynamic_dns.json'); } catch(e) {}
			
			Object.assign(DS, DS_m, DS_d);
			for (var o in DS) {
				if (DS[o] === ip) return o
			}
			return false;
		};	
		this.hubToAServer = function (IO, cfg, incomeData) {
			let me = this;
			var CA = incomeData.toClient.split('->');
			if (CA.length === 2 && pkg.comm.isIp(CA[0])) {
				var link_url = ((isSSL) ? 'https://' : 'http://') + me.ip2host(CA[0]) + '/'
				var ioCSocket = ioClient.connect(link_url, {reconnection: false, timeout:3000, 'connect_timeout': 3000});
				
				ioCSocket.on('connect', function() {
					IO.io.to(`${me._socket.id}`).emit('clientMessage', {
						session_id 	: incomeData.session_id,
						data 		: {
							fromClient : IO.mapping[incomeData.fromClient],
							toClient : IO.mapping[incomeData.toClient],
							body : incomeData.data.body
						}	
					});
					ioCSocket.disconnect();
				});
				ioCSocket.on('connect_error', function(error){
				   ioCSocket.disconnect();
				});

				ioCSocket.on('connect_timeout', (timeout) => {
					ioCSocket.disconnect();
				});
			}
		}
		
		this.hubRoom = function (cfg, incomeData) {
			let me = this, clusters =  me.getCluster(cfg.host);
			
			var CP = new pkg.crowdProcess(), _f = {};
			for(o in clusters) {
				_f[o] = (function(o) { 
					return function(cbk) {
						var link_url = ((isSSL) ? 'https://' : 'http://') + o + '/';
						var ioCSocket = ioClient.connect(link_url, {reconnection: false, timeout:3000, 'connect_timeout': 3000});
						
						ioCSocket.on('connect', function() {
							if (incomeData.data) {
								ioCSocket.emit('hubProxy', {
								    session_id : incomeData.session_id,
								    from : incomeData.from,
								    proxy : ioCSocket.id,
								    to : incomeData.to,
								    data : incomeData.data
								  }, (data) => {});
							} 									
							ioCSocket.disconnect();
							cbk(true);
						});

						ioCSocket.on('connect_error', function(error){
						    cbk(false);
						});
						
						ioCSocket.on('connect_timeout', (timeout) => {
							 cbk(false);
						});
						
						ioCSocket.on('disconnected', function(){
						    cbk(true);
						});
						
					} 
				})(o)
			}
			CP.parallel(_f, function(data) {
			}, 60000);
		};
		
		this.hubQuery = function (cfg, room, session_id, IO) {
			let me = this, clusters =  me.getCluster(cfg.host);
			
			var CP = new pkg.crowdProcess(), _f = {};
			_f['self'] = function(cbk)  {
				IO.io.in(room).clients((err, clients) => {
					var obj_clients = {};
					for (var i = 0 ;  i < clients.length; i++) {
						//var uniqueId = pkg.comm.getSERVERID() + '_' + clients[i].replace(/\/\#/g, '');
						var uniqueId = me.CommIP  + '->' + clients[i].replace(/\/\#/g, '');
						obj_clients[uniqueId] =  (IO.mapping[uniqueId]) ? IO.mapping[uniqueId] : '';
					}
					cbk(obj_clients);
				});
			};
			for(o in clusters) {
				_f[o] = (function(o) { 
					return function(cbk) {
						var link_url = ((isSSL) ? 'https://' : 'http://') + o + '/';
						var ioCSocket = ioClient.connect(link_url, {reconnection: false, timeout:3000, 'connect_timeout': 3000});
						
						ioCSocket.on('connect', function() {
							ioCSocket.on('hubQueryClients_' + session_id, function(data){
								ioCSocket.off('hubQueryClients_' + session_id);
								ioCSocket.disconnect();
								cbk(data);
							      });
							ioCSocket.emit('hubQueryClients', {room:  room, hub : o, session_id: session_id});
						});
						ioCSocket.on('connect_error', function(error){
						    cbk(false);
						});
						
						ioCSocket.on('connect_timeout', (timeout) => {
							 cbk(false);
						});
					}
				})(o)
			}
			CP.parallel(_f, function(data) {
				var clients = {};
				for (o in data.results) {
					if (typeof data.results[o] === 'object') {
						for (p in data.results[o]) {
							clients[p] = data.results[o][p]
						}
					}
				}
				// IO.io.to(room).emit('roomCilents', {
				IO.io.to(`${me._socket.id}`).emit('roomCilents', {
					session_id 	: session_id,
					data: {
						room		: room,
						clients		: clients
					}
				});
			}, 6000);
		};
		
		me.roomNotice = function (IO, socket, data) {
			let me = this;
			IO.io.to(socket.id).emit('clientRequestResponse', {data : data});	
		};
		me.callbackMessage = function (IO, data) {
			let me = this;
			IO.io.to(me._socket.id).emit('callbackMessage', {data : data});	
		};
		me.onConnection = function (IO, socket) {
			
			var host = (!socket || !socket.handshake || !socket.handshake.headers) ? '' : socket.handshake.headers.host;
			if (pkg.comm.isIp(host)) {
				return true;
			}
			me.CommIP = me.host2ip(host);
			me._socket = socket;
			
			if (!me.CommIP) {
				return true;
			}
			
			var uniqueId = me.CommIP  + '->' + socket.id.replace(/\/\#/g, '');
			
			IO.io.to(socket.id).emit('uniqueId', uniqueId);
			IO.mapping[uniqueId] = '';
			
			var sequenceNumberByClient = new Map();	
			
			if(!host.match(/^comm([0-9]+)\_(qa|dev|prod)\.([a-z0-9]+)\.([a-z0-9]+)$/ig)) { 
				socket.disconnect();
				return true;
			} 
			var cfg = {
				socketid : socket.id,
				host : (!socket || !socket.handshake || !socket.handshake.headers) ? '' : socket.handshake.headers.host,
				query : (!socket || !socket.handshake || !socket.handshake.query) ? {} : socket.handshake.query
			};
			
			socket.on('clientRequest', function(incomeData){ 
				incomeData.session_id = new Date().getTime() + '.' + ((!incomeData.session_id) ? '' : incomeData.session_id)  + '.' + me.getSN();
				switch(incomeData.cmd) {
					case 'sendToRoom':
						if (!incomeData.room) {
							/*  === TODO===
							me.sendResponse(IO, cfg, {socket_id: socket.id,
								Err : 'Missing room'});*/
						} else {
						//	 socket.join(incomeData.room, function() {	
								IO.io.in(incomeData.room).clients((err, clients) => {
									if (!err)  {
										me.hubRoom(cfg, {
											session_id : incomeData.session_id,
											data : incomeData.data,
											from: socket.id,
											to : incomeData.room
										});
					
										var uniqueId = me.CommIP + '->'  +socket.id.replace(/\/\#/g, '');
										IO.io.to(incomeData.room).emit('clientMessage', {
											session_id:incomeData.session_id,
											from: socket.id,
											to : incomeData.room,
												data : {
												fromClient : IO.mapping[uniqueId],
												body : incomeData.data.body,
											}	
										});
										/*  === TODO===
										me.sendResponse(IO, cfg, {session_id:incomeData.session_id, socket_id: socket.id,
										  Err: (err)? err : null, 
										result: { status: 'success'}});
										*/
									}
								});
						//	});
						}
						break;

					
					case 'sendToClient':
						incomeData.toClient =  uniqueId;
						incomeData.fromClient =  uniqueId;
						if (!incomeData.toClient) {
							/*
							me.sendResponse(IO, socket, {socket_id: socket.id,
								Err : 'Missing toClient'});
								*/
						} else {
							me.hubToAServer(IO, cfg, incomeData);
						}
						break;
					case 'leaveRoom':
						socket.leave(incomeData.room,  function() {
							me.hubQuery(cfg, incomeData.room, incomeData.session_id, IO);
							/*
							IO.io.in(incomeData.room).clients((err, clients) => {
								//
								me.sendResponse(IO, cfg, {session_id:incomeData.session_id, socket_id: socket.id,
								  Err: (err)? err : null,
								  result: { status: 'success', clients : clients}});
								  //
							}); */
						});
						break;
					case 'joinRoom':
						if (!incomeData.room) {
							/*
							me.sendResponse(IO, socket, {socket_id: socket.id,
								Err : 'Missing room'});
								*/
						} else {
							socket.join(incomeData.room, function() {
								me.hubQuery(cfg, incomeData.room, incomeData.session_id, IO);	
								
								me.callbackMessage(IO, {socket_id: socket.id, Success : true});
								
							});
						}
						break;
						
					case 'roomClients':
						me.hubQuery(cfg, incomeData.room, incomeData.session_id, IO);
						break;
					default : 
						/*
						me.sendResponse(IO, socket, {socket_id: socket.id,Err : 'Missing cmd'});
						*/
				}
			});
			
			socket.on('hubProxy', function(incomeData){
				IO.io.to(incomeData.to).emit('clientMessage', {
					session_id : incomeData.session_id,
					data: incomeData.data,
					proxy: socket.id,
					from: incomeData.from,
					to : incomeData.to
				});
			});
			
			socket.on('hubQueryClients', function(incomeData){
				IO.io.in(incomeData.room).clients((err, clients) => {
					var obj_clients = {};
					for (var i = 0 ;  i < clients.length; i++) {
						// var uniqueId = pkg.comm.getSERVERID() + '_' + clients[i].replace(/\/\#/g, '');
						var uniqueId = me.CommIP + '->'  + clients[i].replace(/\/\#/g, '');
						obj_clients[uniqueId] = (IO.mapping[uniqueId]) ? IO.mapping[uniqueId] : '';
					}
					IO.io.to(`${socket.id}`).emit('hubQueryClients_' + incomeData.session_id, obj_clients);
				});
			});
			socket.on('setClientInfo', function(clientInfo){
			    // var uniqueId = pkg.comm.getSERVERID() + '_' + socket.id.replace(/\/\#/g, '');
			     var uniqueId = me.CommIP + '->' + socket.id.replace(/\/\#/g, '');
			     IO.mapping[uniqueId] = clientInfo;
			});			

			sequenceNumberByClient.set(socket, 1);
			socket.on("disconnect", () => {
				delete IO.mapping[uniqueId];
				sequenceNumberByClient.delete(socket);
			});
		};
		
	};
	
	if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
		module.exports = obj;
	} 
	
})();
