(function () {
	var obj =  function (IO, env, pkg, server, host, isSSL) {
		let me = this;
		var ioClient = require(env.root_path + '/package/socket.io-client/node_modules/socket.io-client');
		this.getSN = function() {
			this._SN = (!this._SN || this._SN > 999999) ? 1 : (this._SN + 1);
			return '' + this._SN;
		}

		this.clientToclient = function (incomeData) {
			let me = this;
			var CA = incomeData.toClient.split('->');
			if (CA.length === 2 && pkg.comm.isIp(CA[0])) {
				var link_url = ((isSSL) ? 'https://' : 'http://') + IO.ip2host(CA[0]) + '/';
				me.hubLink(link_url, 
					function(client_socket, pool) {
						client_socket.emit('hubProxy', {
							session_id 	: incomeData.session_id,
							to : '/#' + CA[1],
							data 		: {
								fromClient : IO.mapping[incomeData.fromClient],
								toClient : IO.mapping[incomeData.toClient],
								body : incomeData.data.body,
								POOL : me._socket.id + '--9999--> -' +  host,
								getCluster : IO.getCluster(host),
								p : pool
							}
						}); 
					},
					function() {
					}
				);
			}
		}
		
		this.hubRoom = function (incomeData) {
			let me = this, clusters =  IO.getCluster(host);
			
			var CP = new pkg.crowdProcess(), _f = {};
			for(o in clusters) {
				_f[o] = (function(o) { 
					return function(cbk) {
						
					var link_url = ((isSSL) ? 'https://' : 'http://') + o + '/';
					me.hubLink(link_url, 
						function(client_socket, pool) {
							client_socket.emit('hubProxy', {
							    session_id : incomeData.session_id,
							    from : incomeData.from,
							    proxy : client_socket.id,
							    to : incomeData.to,
							    data : incomeData.data,
							    p : pool
							}); 
							cbk(true);
						},
						function() {
							cbk(false);
						});
					}	
					
				})(o)
			}
			CP.parallel(_f, function(data) {
			}, 60000);
		};

		this.hubQuery = function (room, session_id, IO, callback) {
			let me = this, clusters =  IO.getCluster(host);
			
			var CP = new pkg.crowdProcess(), _f = {};
			_f['self'] = function(cbk)  {
				IO.io.in(room).clients((err, clients) => {
					var obj_clients = {};
					for (var i = 0 ;  i < clients.length; i++) {
						//var uniqueId = pkg.comm.getSERVERID() + '_' + clients[i].replace(/\/\#/g, '');
						var uniqueId = me.CommIP  + '->' + clients[i].replace(/\/\#/g, '');
						obj_clients[uniqueId] =  (IO.mapping[uniqueId]) ? IO.mapping[uniqueId] : '';
					}
					cbk(obj_clients);
				});
			};
			for(o in clusters) {
				_f[o] = (function(o) { 
					return function(cbk) {
						var link_url = ((isSSL) ? 'https://' : 'http://') + o + '/';
						me.hubLink(link_url, 
						function(client_socket, pool) {
							client_socket.on('hubQueryClients_' + session_id, function(data){
								client_socket.off('hubQueryClients_' + session_id);
								client_socket.disconnect();
								cbk(data);
							      });
							client_socket.emit('hubQueryClients', {room:  room, hub : o, session_id: session_id,  p : pool});
						},
						function() {
							cbk(false);
						});
					}
				})(o)
			}
			CP.parallel(_f, function(data) {
				var clients = {};
				for (o in data.results) {
					if (typeof data.results[o] === 'object') {
						for (p in data.results[o]) {
							clients[p] = data.results[o][p]
						}
					}
				}
				callback({room	: room, clients	: clients});
			}, 6000);
		};

		me.callbackMessage = function (data) {
			let me = this;
			data.socket = me._socket.id;
			IO.io.to(me._socket.id).emit('callbackMessage', data);	
		};
		me.onConnection = function (socket) {

			me.CommIP = IO.host2ip(host);
			me._socket = socket;
			
			if (!me.CommIP) {
				return true;
			}
			var uniqueId = me.CommIP  + '->' + socket.id.replace(/\/\#/g, '');
			
			IO.io.to(socket.id).emit('uniqueId', uniqueId);
			IO.mapping[uniqueId] = '';
			
			var sequenceNumberByClient = new Map();	
			
			if(!host.match(/^comm([0-9]+)\_(qa|dev|prod)\.([a-z0-9]+)\.([a-z0-9]+)$/ig)) { 
				socket.disconnect();
				return true;
			} 

			socket.on('clientRequest', function(incomeData){ 
				incomeData.session_id = new Date().getTime() + '.' + ((!incomeData.session_id) ? '' : incomeData.session_id)  + '.' + me.getSN();
				switch(incomeData.cmd) {
					case 'sendToRoom':
						if (!incomeData.room) {
							me.callbackMessage({
								session_id : incomeData.session_id,
								data: {success : false, data: 'Unsuccess'}
							});
						} else {
						//	 socket.join(incomeData.room, function() {	
								IO.io.in(incomeData.room).clients((err, clients) => {
									if (!err)  {
										me.hubRoom({
											session_id : incomeData.session_id,
											data : incomeData.data,
											from: socket.id,
											to : incomeData.room
										});
					
										var uniqueId = me.CommIP + '->'  +socket.id.replace(/\/\#/g, '');
										IO.io.to(incomeData.room).emit('clientMessage', {
											session_id:incomeData.session_id,
											from: socket.id,
											to : incomeData.room,
												data : {
												fromClient : IO.mapping[uniqueId],
												body : incomeData.data.body,
											}	
										});
									}
								});
						//	});
						}
						break;

					
					case 'clientToclient':
						if (incomeData.toClient) {
							incomeData.fromClient =  uniqueId;
							if (!incomeData.toClient) {
								me.callbackMessage({
									session_id : incomeData.session_id,
									data: {success : false, data: 'Unsuccess'}
								});
							} else {
								me.clientToclient(incomeData);
							}	
						}
						break;
					case 'leaveRoom':
						socket.leave(incomeData.room,  function() {
							me.hubQuery(incomeData.room, incomeData.session_id, IO,
								function(data) {
									me.callbackMessage({
										session_id : incomeData.session_id,
										data: {data:data, success : true}
									});
							});
						});
						break;
					case 'joinRoom':
						if (!incomeData.room) {
							me.callbackMessage({
								session_id : incomeData.session_id,
								data: {success : false, data: 'Miss room'}
							});
						} else {
							socket.join(incomeData.room, function() {
								me.hubQuery(incomeData.room, incomeData.session_id, IO,
									function(data) {
									me.callbackMessage({
										session_id : incomeData.session_id,
										data: {data:data, success : true,
										      handshake : socket.handshake
											  // socket.request.connection.remoteAddress
										}
									});
								
								});
							});
						}
						break;
						
					case 'roomClients':
						me.hubQuery(incomeData.room, incomeData.session_id, IO,
						    function(data) {
							me.callbackMessage({
								session_id : incomeData.session_id,
								data: {data:data, success : true}
							});
						});
						break;
					default : 
						me.callbackMessage({
							session_id : incomeData.session_id,
							data: {success : false, data: 'miss cmd'}
						});
				}
			});
			
			socket.on('hubProxy', function(incomeData){
				incomeData.data.p = incomeData.p;
				IO.io.to(incomeData.to).emit('clientMessage', {
					session_id : incomeData.session_id,
					data: incomeData.data,
					proxy: socket.id,
					from: incomeData.from,
					to : incomeData.to
				});
			});
			
			socket.on('hubQueryClients', function(incomeData){
				IO.io.in(incomeData.room).clients((err, clients) => {
					var obj_clients = {};
					for (var i = 0 ;  i < clients.length; i++) {
						// var uniqueId = pkg.comm.getSERVERID() + '_' + clients[i].replace(/\/\#/g, '');
						var uniqueId = me.CommIP + '->'  + clients[i].replace(/\/\#/g, '');
						obj_clients[uniqueId] = (IO.mapping[uniqueId]) ? IO.mapping[uniqueId] : '';
					}
					IO.io.to(`${socket.id}`).emit('hubQueryClients_' + incomeData.session_id, obj_clients);
				});
			});
			socket.on('setClientInfo', function(clientInfo){
			    // var uniqueId = pkg.comm.getSERVERID() + '_' + socket.id.replace(/\/\#/g, '');
			     var uniqueId = me.CommIP + '->' + socket.id.replace(/\/\#/g, '');
			     IO.mapping[uniqueId] = clientInfo;
			});			

			sequenceNumberByClient.set(socket, 1);
			socket.on("disconnect", () => {
				delete IO.mapping[uniqueId];
				sequenceNumberByClient.delete(socket);
			});
		};
		
	};
	
	if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
		module.exports = obj;
	} 
})();
