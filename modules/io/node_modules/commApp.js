(function () {
	var obj =  function (IO, env, pkg, _pool, server, host, isSSL) {
		let me = this;
		this.searchCommServer = function (callback) {
			let me = this, clusters =  IO.getTypeCluster('comm');	
			var CP = new pkg.crowdProcess(), _f = {};
			var list = [];
			
			for(o in clusters) {
				_f[o] = (function(o) { 
					return function(cbk) {
					var link_url = ((isSSL) ? 'https://' : 'http://') + o + '/';
					IO.commLink(link_url, host,
						function(client_socket, pool) {
							list.push(o);
							cbk(true);
						},
						function() {
							cbk(false);
						});
					}	
					
				})(o)
			}
			CP.parallel(_f, function(data) {
				callback(list);
			}, 6000);
		};	

		this.hubRoomBroadcast = function (room, incomeData) {
			let me = this, clusters =  IO.getCluster(host);
			
			var CP = new pkg.crowdProcess(), _f = {};
			_f['self'] = function(cbk)  {
				me.deliveryMessage(room, incomeData);
				cbk(true);
			};
			for(o in clusters) {
				_f[o] = (function(o) { 
					return function(cbk) {
					var link_url = ((isSSL) ? 'https://' : 'http://') + o + '/';
					IO.hubLink(link_url, host,
						function(client_socket, pool) {
							client_socket.emit('hubProxyRoomBroadcast', {
								room : room,
								data : incomeData
							}); 
							cbk(true);
						},
						function() {
							cbk(false);
						});
					}	
					
				})(o)
			}
			CP.parallel(_f, function(data) {
			}, 6000);
		};
		
		
		this.hubQuery = function (room, session_id, IO, callback) {
			let me = this, clusters =  IO.getCluster(host);
			var CP = new pkg.crowdProcess(), _f = {};
			_f['self'] = function(cbk)  {
				IO.io.in(room).clients((err, clients) => {
					var obj_clients = {};
					for (var i = 0 ;  i < clients.length; i++) {
						//var uniqueId = pkg.comm.getSERVERID() + '_' + clients[i].replace(/\/\#/g, '');
						var uniqueId = me.CommIP  + '->' + clients[i].replace(/\/\#/g, '');
						obj_clients[uniqueId] =  (IO.mapping[uniqueId]) ? IO.mapping[uniqueId] : '';
					}
					cbk(obj_clients);
				});
			};
			for(o in clusters) {
				_f[o] = (function(o) { 
					return function(cbk) {
						var link_url = ((isSSL) ? 'https://' : 'http://') + o + '/';
						IO.hubLink(link_url, host,
						function(client_socket, pool) {
							client_socket.on('hubQueryClients_' + session_id, function(data){
								client_socket.off('hubQueryClients_' + session_id);
								// client_socket.disconnect();
								cbk(data);
							      });
							client_socket.emit('hubQueryClients', {room:  room, hub : o, session_id: session_id,  p : pool});
						},
						function() {
							
							cbk(false);
						});
					}
				})(o)
			}
			CP.parallel(_f, function(data) {
				var clients = {};
				for (o in data.results) {
					if (typeof data.results[o] === 'object') {
						for (p in data.results[o]) {
							clients[p] = data.results[o][p]
						}
					}
				}
				callback({room	: room, clients	: clients});
			}, 6000);
		};
		
		me.callbackMessage = function (data) {
			let me = this;
			// data.socket = me._socket.id;
			data.isSSL = isSSL;
			IO.io.to(me._socket.id).emit('_callbackMessage_', data);
		};
		me.deliveryMessage = function (toId, data) {
			let me = this;
			//IO.io.to(me._socket.id).emit('_incomeMessage_', data);
			IO.io.to(toId).emit('_incomeMessage_', data);	
		};
	
		me.onConnection = function (socket) {
			me.CommIP = IO.host2ip(host);
			me._socket = socket;
			
			if (!me.CommIP) {
				return true;
			}
			var sequenceNumberByClient = new Map();	
			
			if (!IO.isIOSType(host, 'comm')) {
				socket.disconnect();
				return true;
			}
			
			
			socket.on('clientRequest', function(incomeData){ 
				incomeData.session_id = new Date().getTime() + '.' + ((!incomeData.session_id) ? '' : incomeData.session_id)  + '.' + IO.getSN();
				switch(incomeData.cmd) {
					case 'joinRoom':
						if (!incomeData.room) {
							me.callbackMessage({
								session_id : incomeData.session_id,
								data: {success : false, data: 'Miss room'}
							});
						} else {
							me.deliveryMessage(incomeData.room, incomeData);
						}
						break;
					case 'roomServers':
						me.searchCommServer(
							function(list_servers) {
								me.callbackMessage({
									session_id : incomeData.session_id,
									success : true,
									list : list_servers
								});
							}
						);

						break;
					default : 
						me.deliveryMessage(me._socket.id, {
							session_id : incomeData.session_id,
							data: {success : false, data: 'miss cmd'}
						});
				}
			});
			
			sequenceNumberByClient.set(socket, 1);
			
			socket.on("disconnect", () => {
				console.log('--PPP--' + host);
				me.hubRoomBroadcast('PPV', 'NIUPI->' + socket.id);
				
				// delete IO.mapping[uniqueId];
				sequenceNumberByClient.delete(socket);
			});
		};
		
	};
	
	if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
		module.exports = obj;
	} 
})();
